use full_moon::{
    ast::{
        punctuated::Punctuated,
        span::ContainedSpan,
        types::{ExportedTypeDeclaration, TypeDeclaration, TypeField, TypeInfo},
        Stmt,
    },
    tokenizer::{Token, TokenReference, TokenType},
    ShortString,
};
use oas3::{spec::ObjectOrReference, OpenApiV3Spec, Schema};

const HEADER_COMMENT: &str = "--[[
\tThis file was generated by openapi-luau.
\tDon't make manual changes.
]]\n";

fn generate_luau_type_from_schema_object(name: &str, schema: Schema) -> ExportedTypeDeclaration {
    let fields: Punctuated<TypeField> = Punctuated::new();

    for (propName, prop) in schema.properties {
        let mut is_required = false;
        for other in schema.required.iter() {
            if propName.eq(other) {
                println!("{} is required", propName);
                is_required = true;
            }
        }
        // TODO: Push to `fields`
    }

    let braces = ContainedSpan::new(
        TokenReference::new(
            vec![],
            Token::new(TokenType::Identifier {
                identifier: ShortString::new("{"),
            }),
            vec![],
        ),
        TokenReference::new(
            vec![],
            Token::new(TokenType::Identifier {
                identifier: ShortString::new("}"),
            }),
            vec![],
        ),
    );

    // TODO: Traverse over `v` to generate the full type
    // fields.push(TypeField::new());
    let type_decl = TypeDeclaration::new(
        TokenReference::new(
            vec![],
            Token::new(TokenType::Identifier {
                identifier: name.into(),
            }),
            vec![],
        ),
        // TODO: Use type of `v` to construct the type
        TypeInfo::Table { braces, fields },
    );

    ExportedTypeDeclaration::new(type_decl)
}

pub fn generate_luau_types(spec: OpenApiV3Spec) -> Vec<ExportedTypeDeclaration> {
    let mut types = vec![];

    if let Some(components) = spec.components {
        for (name, object_or_ref) in components.schemas {
            // TODO: If v is a ref then use the type name?

            match object_or_ref {
                ObjectOrReference::Object(obj) => {
                    types.push(generate_luau_type_from_schema_object(&name, obj))
                }
                ObjectOrReference::Ref { ref_path } => println!("ref {:?}", ref_path),
            }
        }
    }

    types
}
