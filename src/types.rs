use full_moon::{
    ast::{
        punctuated::Punctuated,
        span::ContainedSpan,
        types::{ExportedTypeDeclaration, TypeDeclaration, TypeField, TypeInfo},
        Stmt,
    },
    tokenizer::{Token, TokenReference, TokenType},
    ShortString,
};
use oas3::{spec::ObjectOrReference, OpenApiV3Spec, Schema};

const HEADER_COMMENT: &str = "--[[
\tThis file was generated by openapi-luau.
\tDon't make manual changes.
]]\n";

fn generate_luau_type_from_schema_object(schema: Schema) -> ExportedTypeDeclaration {
    let fields: Punctuated<TypeField> = Punctuated::new();

    for (name, prop) in schema.properties {
        let mut is_required = false;
        for other in schema.required.iter() {
            if name.eq(other) {
                println!("{} is required", name);
                is_required = true;
            }
        }
    }

    let braces = ContainedSpan::new(
        TokenReference::new(
            vec![],
            Token::new(TokenType::Identifier {
                identifier: ShortString::new("{"),
            }),
            vec![],
        ),
        TokenReference::new(
            vec![],
            Token::new(TokenType::Identifier {
                identifier: ShortString::new("}"),
            }),
            vec![],
        ),
    );

    // TODO: Traverse over `v` to generate the full type
    // fields.push(TypeField::new());
    let type_decl = TypeDeclaration::new(
        TokenReference::new(
            vec![],
            Token::new(TokenType::Identifier {
                identifier: k.into(),
            }),
            vec![],
        ),
        // TODO: Use type of `v` to construct the type
        TypeInfo::Table { braces, fields },
    );

    ExportedTypeDeclaration::new(type_decl)
}

pub fn generate_luau_types(spec: OpenApiV3Spec) -> Vec<ExportedTypeDeclaration> {
    let mut types = vec![];

    if let Some(components) = spec.components {
        for (k, v) in components.schemas {
            // TODO: If v is a ref then use the type name?

            match v {
                ObjectOrReference::Object(obj) => println!("object {:?}", obj),
                ObjectOrReference::Ref { ref_path } => println!("ref {:?}", ref_path),
            }

            let fields: Punctuated<TypeField> = Punctuated::new();

            let braces = ContainedSpan::new(
                TokenReference::new(
                    vec![],
                    Token::new(TokenType::Identifier {
                        identifier: ShortString::new("{"),
                    }),
                    vec![],
                ),
                TokenReference::new(
                    vec![],
                    Token::new(TokenType::Identifier {
                        identifier: ShortString::new("}"),
                    }),
                    vec![],
                ),
            );

            // TODO: Traverse over `v` to generate the full type
            // fields.push(TypeField::new());
            let type_decl = TypeDeclaration::new(
                TokenReference::new(
                    vec![],
                    Token::new(TokenType::Identifier {
                        identifier: k.into(),
                    }),
                    vec![],
                ),
                // TODO: Use type of `v` to construct the type
                TypeInfo::Table { braces, fields },
            );

            types.push(ExportedTypeDeclaration::new(type_decl));
        }
    }

    types
}
